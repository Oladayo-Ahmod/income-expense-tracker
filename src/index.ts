import { query,int, update,text,Principal,float64, Record, 
    StableBTreeMap, Vec, Result, nat64, ic, Opt, Err, Ok, Canister, bool, Variant, nat32 }
 from 'azle';
import { v4 as uuidv4 } from 'uuid';


// user
const User = Record({
    id: Principal,
    username: text,
    expensesIds: Vec(text),
    incomesIds: Vec(text)
});

type User = typeof User;

// Expenses
const Expenses = Record({
    id : text,
    name : text,
    userId : Principal,
    amount : float64,
    description : text,
    location : text, // where the expenses take place
    timestamp : nat64
});

type Expenses = typeof Expenses;

// income
const Income = Record({
    id : text,
    name : text,
    userId : Principal,
    amount : float64,
    description : text,
    location : text, // where the income take place
    timestamp : nat64
});

type Income = typeof Income;
// tracker
const Tracker = Record({
    totalExpenses : float64,
    totalIncome : float64,
    balance : float64,
    users : Vec(User)
});

// tracker storage
const trackerStorage : typeof Tracker = {
    totalExpenses : 0,
    totalIncome : 0,
    balance : 0,
    users : []
}


const Transactions = Record({
  incomes: Vec(Income),
  expenses: Vec(Expenses)
})

type Transactions = typeof Transactions;

const userStorage = StableBTreeMap(Principal,User,1);
const incomeStorage = StableBTreeMap(text,Income,2) //income storage
const expenseStorage = StableBTreeMap(text,Expenses,3) // expense storage
const usernameStorage= StableBTreeMap(text, Principal,4)

// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}
// Helper function to ensure the input id meets the format used for ids generated by uuid
function getExpenses(user: User): Vec<Expenses> {
  const expenses : Vec<Expenses> = [];
  user.expensesIds.forEach((expenseId: text) => {
    const expenseOpt = expenseStorage.get(expenseId);
    if ('None' in expenseOpt){
      return;
    }else{
      expenses.push(expenseOpt.Some)
      return;
    }
  });
  return expenses;
}
// Helper function to ensure the input id meets the format used for ids generated by uuid
function getIncomes(user: User): Vec<Income> {
  const incomes : Vec<Income> = [];
  user.incomesIds.forEach((incomeId: text) => {
    const incomeOpt = incomeStorage.get(incomeId);
    if ('None' in incomeOpt){
      return;
    }else{
      incomes.push(incomeOpt.Some)
      return;
    }
  });
  return incomes;
}

function convertTimestampToDateObject(timestamp: nat64) : Date{
  let millisecondsToNanoseconds = BigInt(1000000);
  let convertedTime: nat32 = Number(timestamp / millisecondsToNanoseconds);
  return new Date(convertedTime);
}


export default Canister({
// create new user
createUser: update(
  [text],
  Result(text, text),
  (username :string) => {
    const isUsernameTaken = usernameStorage.containsKey(username);
    if (isUsernameTaken) {
      return Err('Username is already taken.');
    }
    const caller = ic.caller();
    const isCallerRegistered = userStorage.containsKey(caller);
    if (isCallerRegistered){
      return Err("Caller is already a registered user")
    }

    const newUser: User = {
      id: caller,
      username,
      expensesIds: [],
      incomesIds: []
    };

    usernameStorage.insert(username, newUser.id);
    userStorage.insert(newUser.id, newUser);
    return Ok(`${newUser.username} added successfully.`);
  }
),

// get current user
getCurrentUser : query([], Result(User, text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }
  return Ok(userOpt.Some);
}),

// add expense
addExpense: update(
  [text,float64,text,text],
  Result(text, text),
  (name,amount,description,location) => {
    const caller = ic.caller();
    const userOpt = userStorage.get(caller);
    if ('None' in userOpt) {
      return Err('user does not exist.');
    }
    const user: User = userOpt.Some;

    const newExpense: typeof Expenses = {
      id: uuidv4(),
      name,
      userId : user.id,
      amount,
      description,
      location,
      timestamp: ic.time(),
    };

    user.expensesIds.push(newExpense.id);
    userStorage.insert(user.id, user);
    expenseStorage.insert(newExpense.id, newExpense);
    // userStorage.insert(currentUser.id, { ...currentUser });
    return Ok('Expenses added successfully.');
  }
),

// add income
addIncome: update(
  [text,float64,text,text],
  Result(text, text),
  (name,amount,description,location) => {
    const caller = ic.caller();
    const userOpt = userStorage.get(caller);
    if ('None' in userOpt) {
      return Err('user does not exist.');
    }
    const user: User = userOpt.Some;

    const newIncome: typeof Income = {
      id: uuidv4(),
      name,
      userId : user.id,
      amount,
      description,
      location,
      timestamp: ic.time(),
    };
    user.incomesIds.push(newIncome.id);
    userStorage.insert(user.id, user);
    incomeStorage.insert(newIncome.id, newIncome);
    // userStorage.insert(currentUser.id, { ...currentUser });
    return Ok('Income added successfully.');
  }
),

// retrieve current user incomes
getCurrentUserIncome: query([], Result(Vec(Income), text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }
  const user: User = userOpt.Some;

  const incomes = getIncomes(user);
  return Ok(incomes);
}),

// retrieve current user expenses
getCurrentUserExpenses: query([], Result(Vec(Expenses), text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }
  const user: User = userOpt.Some;

  const expenses = getExpenses(user);
  return Ok(expenses);
}),

 // retrieve current user balance
 getCurrentUserBalance: query([], Result(text, text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }
  const user = userOpt.Some;
  const incomes = getIncomes(user);
  const expenses = getExpenses(user);


  const totalIncome = incomes.reduce(
    (sum : any, income : Income) => sum + income.amount,
    0
  );

  const totalExpenses = expenses.reduce(
    (sum :float64, expense :Expenses) => sum + expense.amount,
    0
  );

  const balance = totalIncome - totalExpenses;

  return Ok(balance >= 0 ? `${balance} 'Surplus'` : `${balance}'Deficit'`);
}),

// retrieve current user expenses for the current month
getCurrentUserExpensesForCurrentMonth: query([], Result(Vec(Expenses), text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }

  const user : User = userOpt.Some;

  const currentDate = new Date();
  const currentMonth = currentDate.getMonth() + 1; // Months are 0-indexed, so we add 1.

  const expenses = getExpenses(user);
  const currentUserExpenses = expenses.filter(
    (expense: Expenses) => {
      const expenseMonth = convertTimestampToDateObject(expense.timestamp).getMonth() + 1;
      return expenseMonth === currentMonth;
    }
  );

  return Ok(currentUserExpenses);
}),

// retrieve current user income for the current month
getCurrentUserIncomeForCurrentMonth: query([], Result(Vec(Income), text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }

  const user : User = userOpt.Some;

  const currentDate = new Date();
  const currentMonth = currentDate.getMonth() + 1; // Months are 0-indexed, so we add 1.

  const incomes = getIncomes(user);
  const currentUserIncome = incomes.filter(
    (income: typeof Income) => {
      const incomeMonth = convertTimestampToDateObject(income.timestamp).getMonth() + 1;
      return incomeMonth === currentMonth;
    }
  );

  return Ok(currentUserIncome);
}),

// retrieve current user income and expenses for the year
getCurrentUserTransactionsForCurrentYear: query([], Result(Transactions, text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }

  const user : User = userOpt.Some;

  const currentDate = new Date();
  const currentYear = currentDate.getFullYear();

  const incomes = getIncomes(user);
  const currentUserIncomes = incomes.filter(
    (income: typeof Income) => {
      const incomeYear = convertTimestampToDateObject(income.timestamp).getFullYear();
      return incomeYear === currentYear;
    }
  );

  const expenses = getExpenses(user);
  const currentUserExpenses = expenses.filter(
    (expense: typeof Expenses) => {
      const expenseYear = convertTimestampToDateObject(expense.timestamp).getFullYear();
      return expenseYear === currentYear;
    }
  );

  const transactions :Transactions = {
    incomes: currentUserIncomes,
    expenses: currentUserExpenses
  }
  return Ok(transactions);
}),


// retrieve current user balance for current month
getCurrentUserBalanceForCurrentMonth: query([], Result(text, text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }

  const user : User = userOpt.Some;

  const currentDate = new Date();
  const currentMonth = currentDate.getMonth() + 1; // Months are 0-indexed, so we add 1.

  const incomes = getIncomes(user);
  const currentUserIncomes = incomes.filter(
    (income: typeof Income) => {
      const incomeMonth =convertTimestampToDateObject(income.timestamp).getMonth() + 1;
      return incomeMonth === currentMonth;
    }
  );

  const expenses = getExpenses(user);
  const currentUserExpenses = expenses.filter(
    (expense: typeof Expenses) => {
      const expenseMonth = convertTimestampToDateObject(expense.timestamp).getMonth() + 1;
      return expenseMonth === currentMonth;
    }
  );

  const totalIncome = currentUserIncomes.reduce(
    (sum :any, income :any) => sum + income.amount,
    0
  );

  const totalExpenses = currentUserExpenses.reduce(
    (sum :any, expense :any) => sum + expense.amount,
    0
  );
  const balance = totalIncome - totalExpenses;

  const isBalancePositive = totalIncome > totalExpenses;
  
  return Ok(isBalancePositive ? `'Surplus': ${balance}` : `'Deficit': ${balance}`);
}),

// retrieve current user balance for the current day
getCurrentUserBalanceForCurrentDay: query([], Result(text, text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }

  const user : User = userOpt.Some;

  const currentDate = new Date();
  const currentDay = currentDate.getDate();

  const incomes = getIncomes(user);
  const currentUserIncomes = incomes.filter(
    (income: Income) => {
      const incomeDay = convertTimestampToDateObject(income.timestamp).getDate();
      return incomeDay === currentDay;
    }
  );

  const expenses = getExpenses(user);
  const currentUserExpenses = expenses.filter(
    (expense: Expenses) => {
      const expenseDay = convertTimestampToDateObject(expense.timestamp).getDate();
      return expenseDay === currentDay;
    }
  );

  const totalIncome = currentUserIncomes.reduce(
    (sum:any, income:any) => sum + income.amount,
    0
  );

  const totalExpenses = currentUserExpenses.reduce(
    (sum:any, expense:any) => sum + expense.amount,
    0
  );

  const balance = totalIncome - totalExpenses;

  const isBalancePositive = totalIncome > totalExpenses;
  
  return Ok(isBalancePositive ? `'Surplus': ${balance}` : `'Deficit': ${balance}`);

}),

// retrieve current user balance for the current year
getCurrentUserBalanceForCurrentYear: query([], Result(text, text), () => {
  const caller = ic.caller();
  const userOpt = userStorage.get(caller);
  if ('None' in userOpt) {
    return Err('user does not exist.');
  }

  const user : User = userOpt.Some;

const currentDate = new Date();
const currentYear = currentDate.getFullYear();

const incomes = getIncomes(user);
const currentUserIncomes = incomes.filter(
  (income: typeof Income) => {
    const incomeYear = convertTimestampToDateObject(income.timestamp).getFullYear();
    return incomeYear === currentYear;
  }
);

const expenses = getExpenses(user);
const currentUserExpenses = expenses.filter(
  (expense: typeof Expenses) => {
    const expenseYear = convertTimestampToDateObject(expense.timestamp).getFullYear();
    return  expenseYear === currentYear;
  }
);

const totalIncome = currentUserIncomes.reduce(
  (sum:any, income:any) => sum + income.amount,
  0
);

const totalExpenses = currentUserExpenses.reduce(
  (sum:any, expense:any) => sum + expense.amount,
  0
);

const balance = totalIncome - totalExpenses;

const isBalancePositive = totalIncome > totalExpenses;

return Ok(isBalancePositive ? `'Surplus': ${balance}` : `'Deficit': ${balance}`);
}),

})


globalThis.crypto = {
  // @ts-ignore
 getRandomValues: () => {
     let array = new Uint8Array(32)

     for (let i = 0; i < array.length; i++) {
         array[i] = Math.floor(Math.random() * 256)
     }

     return array
 }
}